# -*- coding: utf-8 -*-
"""Tugas Akhir JST - Seeds .ipynb

Automatically generated by Colaboratory.


"""

'''one-hot encoding'''
import numpy as np
def onehot_enc(lbl, min_val=0):
  mi=min(lbl)
  enc=np.full((len(lbl),max(lbl)-mi+1), min_val, np.int8)
  for i, x in enumerate(lbl):
    enc[i, x-mi]=1
  return enc

def onehot_dec(enc, mi=0):
  return [np.argmax(e)+mi for e in enc]

#labels= 1, 2, 3, 4, 5
#enc = onehot_enc(labels)
#dec = onehot_dec(enc, min(labels))
#
#print(enc)
#print(dec)


'''Fungsi aktivasi sigmoid dan turunannya'''

def sig(X):
 return [1/(1+np.exp(-x)) for x in X]

def sigd(X):
 output=[]
 for i, x in enumerate(X):
   s = sig([x])[0]
   output.append(s*(1-s))

 return output

'''fungsi modeling (training backpropagation)'''
def bp_fit(X, target, layer_conf, max_epoch, max_error=.1, learn_rate=.1,print_per_epoch=100):
  nin=[np.empty(i) for i in layer_conf]

  n = [np.empty(j+1) if i<len(layer_conf)-1
      else np.empty(j) for i, j in enumerate(layer_conf)]
      
  w = np.array([np.random.rand(layer_conf[i]+1, layer_conf[i+1])
                for i in range(len(layer_conf)-1)])
  
  dw = [np.empty((layer_conf[i]+1, layer_conf[i+1]))
        for i in range(len(layer_conf)-1)]
        
  d = [np.empty(s) for s in layer_conf[1:]]
  din = [np.empty(s) for s in layer_conf[1:-1]]
  epoch = 0
  mse = 1

  for i in range(0, len(n)-1):
    n[i][-1]=1
  while (max_epoch == -1 or epoch<max_epoch) and mse>max_error:
    epoch +=1
    mse = 0
    for r in range(len(X)):
      n[0][:-1]=X[r]

      for L in range(1, len(layer_conf)):
        nin[L] = np.dot(n[L-1], w[L-1])
        n[L][:len(nin[L])]=sig(nin[L])

      e = target[r] - n[-1]
      mse += sum(e ** 2)
      d[-1]=e*sigd(nin[-1])
      dw[-1]=learn_rate * d[-1]*n[-2].reshape((-1,1))

      for L in range(len(layer_conf)-1, 1, -1):
        din[L-2]=np.dot(d[L-1], np.transpose(w[L-1][:-1]))
        d[L-2]=din[L-2]*np.array(sigd(nin[L-1]))
        dw[L-2]=(learn_rate*d[L-2])*n[L-2].reshape((-1,1))

      w += dw
    mse /= len(X)

    if print_per_epoch > -1 and epoch % print_per_epoch == 0:
      print(f'Epoch {epoch}, MSE: {mse}')

  return w, epoch, mse

'''fungsi pengujian back propagation'''

def bp_predict(X,w):
  n=[np.empty(len(i)) for i in w]
  nin=[np.empty(len(i[0])) for i in w]
  predict = []
  n.append(np.empty(len(w[-1][0])))

  for x in X:
    n[0][:-1]=x

    for L in range(0, len(w)):
      nin[L] = np.dot(n[L], w[L])
      n[L+1][:len(nin[L])] = sig(nin[L])

    predict.append(n[-1].copy())
  
  return predict

# Import library
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import minmax_scale
from sklearn.metrics import accuracy_score

# Load data, pisahkan data dan label

#iris = datasets.load_iris()
#X = minmax_scale(iris.data)
#Y = onehot_enc(iris.target)
seeds_dataset = np.loadtxt('seeds_dataset.txt')

data = seeds_dataset[:, :7]
labels = seeds_dataset[:, 7].reshape((data.shape[0]))

label = []
for i in range (len(labels)) :
  label.append(int(labels[i]))

X = minmax_scale(data)
Y = onehot_enc(label)

# Preprocess data: membagi data training, label training dan data testing, label testing (2/3 data training, 1/3 data testing)
# Atau dengan kata lain Memisahkan data training, data testing, label training, label testing (2/3 data training, 1/3 data testing)

X_train, X_test, y_train, y_test = train_test_split(X,Y,random_state=1,test_size=.33)

# Membangun model JST / backpropagation menggunakan data training dan label training

w, ep, mse = bp_fit(X_train, y_train, layer_conf=(7,10,3),learn_rate=.1, max_epoch=1000, max_error=.1, print_per_epoch=25)

print(f'Epochs: {ep}, MSE: {mse}')

# Menguji model / Menguji kinerja backpropagation menggunakan data testing
predict = bp_predict(X_test, w)
predict = onehot_dec(predict)

predict1 = []
for i in range (len(predict)):
  predict1.append(predict[i]+1)

#Membandingkan luaran dengan label testing / target
y_test = onehot_dec(y_test)
acc = accuracy_score(predict, y_test)

y_test1 = []
for i in range (len(y_test)):
  y_test1.append(y_test[i]+1)

#print(len(X_test))
#print(len(X_train))
print(f'Output: {predict1}')
print(f'True: {y_test1}')
print(f'Accuracy: {acc}')


from sklearn.metrics import confusion_matrix
cf=confusion_matrix(y_test1,predict1)
#print(cf)

import seaborn as sns
import matplotlib.pyplot as plt

categories = ['Kama','Rosa','Canadian']
sns.heatmap(cf, cmap="Blues", annot=True)

title = 'Confusion Matriksnya'
plt.title(title, loc='center')

yticks_labels = ['Kama','Rosa','Canadian']
plt.yticks(np.arange(3) + .5, labels=yticks_labels)
xticks_labels = ['Kama','Rosa','Canadian']
plt.xticks(np.arange(3) + .5, labels=xticks_labels)

plt.xlabel('Label Prediksi')
plt.ylabel('Label Sebenarnya')
plt.show()


#sns.heatmap(cf/np.sum(cf), annot=True, 
#            fmt='.2%', cmap='Blues')
#plt.show()

''' PLOT AKURASI DAN NEURON '''
x = []
y_list = []
for i in range (1,6):
    if i != 7 :
        x.append(i)
        
        X_train, X_test, y_train, y_test = train_test_split(X,Y,random_state=1,test_size=.33)
        w, ep, mse = bp_fit(X_train, y_train, layer_conf=(7,i,3),learn_rate=.1, max_epoch=1000, max_error=.1,print_per_epoch=2000)
        predict = bp_predict(X_test, w)
        predict = onehot_dec(predict)

        y_test = onehot_dec(y_test)
        
        acc = accuracy_score(predict, y_test)
        
        y_list.append(acc)
        print("Selesai")

plt.plot(x,y_list)
plt.xlabel('Jumlah Neuron')
plt.ylabel('Akurasi')
plt.grid()
plt.show()